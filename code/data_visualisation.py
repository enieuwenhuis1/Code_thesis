"""
Author:       Eva Nieuwenhuis
University:   UvA
Student id':  13717405
Description:  In this code functions are given that are used to make the plots. The
              data for the plots is generated by the code in cancer_model.py. The
              plots show the influence of, collective interactions, nonlinear benefits,
              different treatment methods and MM resistance levels.
"""

import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import ternary
import plotly.graph_objects as go
import plotly.express as px
from cancer_model import *
import plotly.io as pio
from scipy.integrate import odeint


def main():
    # Make figure 1 in the paper of Sartakhti et al., 2018.
    figure_1()

    # Make the figures in figure 2 in the paper of Sartakhti et al., 2018.
    figure_2()

    # Make the figures in figure 3 in the paper of Sartakhti et al., 2018.
    figure_3()

    # Make the figures in figure 4 in the paper of Sartakhti et al., 2018.
    figure_4()

    # Make the figures in figure 5 in the paper of Sartakhti et al., 2018.
    figure_5()

    # Make the figures in figure 6 in the paper of Sartakhti et al., 2018.
    figure_6()

    # Make the figures in figure 7 in the paper of Sartakhti et al., 2018.
    figure_7()

    # Make the figures in figure 8 in the paper of Sartakhti et al., 2018.
    figure_8()

    # Make the figures in figure 9 in the paper of Sartakhti et al., 2018.
    figure_9()

    # Make figure 10 in the paper of Sartakhti et al., 2018.
    figure_10()

def save_figure(figure, file_name, folder_path):
    """Save the figure to a specific folder.

    Parameters:
    -----------
    figure: Matplotlib figure
        Figure object that needs to be saved.
    file_name : String
        The name for the plot.
    folder_path: String:
        Path to the folder where the data will be saved.
    """
    os.makedirs(folder_path, exist_ok=True)
    figure.savefig(os.path.join(folder_path, file_name))

def save_ternary(figure, file_name, folder_path):
    """Save the ternary plot in a specific folder.

    Parameters:
    -----------
    figure: Matplotlib figure
        Figure object that needs to be saved.
    file_name : String
        The name for the plot.
    folder_path: String:
        Path to the folder where the data will be saved.
    """
    os.makedirs(folder_path, exist_ok=True)
    pio.write_image(figure, os.path.join(folder_path, f'{file_name}.png'), format='png')

"""Figure in materials and methods (figure 10)"""
def figure_10():
    """Function that recreates figure 10 in the paper of Sartakhti et al., 2018."""
    # Parameters
    N = 10
    h_value = 0.4
    B_value = 1.0

    # Steepness values
    steepness_values = [0.1, 1.0, 10.0, 20.0, 100.0]

    # Create a data frame
    df_figure_10 = pd.DataFrame(columns=['n_values', 'benefit_values', 's_value'])

    # Loop over the steepness values
    for s_value in steepness_values:
        n_values = np.linspace(0, N, 100)
        benefit_data= [benefit_function(n, h_value, B_value, s_value, N) for n in n_values]
        df_figure_10 = pd.concat([df_figure_10, pd.DataFrame({'n_values': n_values,
                                    'benefit_values': benefit_data, 's_value': s_value})])

    # Save the data as csv file
    save_data(df_figure_10, 'data_figure_10.csv', r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_10 = collect_data('data_figure_10.csv',
                                            r'..\data\reproduced_data_Sartakhti')

    # Make a plot
    fig, ax = plt.subplots(figsize=(10, 6))
    for s_value, group in data_figure_10.groupby('s_value'):
        plt.plot(group['n_values'], group['benefit_values'], label=f's={s_value}')

    # Make the plot clear
    ax.set_xticks([0, 10])
    ax.set_xticklabels(['0', 'N'], fontsize=11)
    ax.set_yticks([0, 1])
    ax.set_yticklabels(['0', r'$B_{ij}$'], fontsize=11)
    plt.title('Sigmoide benefits for different inflection points')
    plt.xlabel('Number of cells (ni)')
    plt.ylabel('Benefit')
    plt.legend()
    save_figure(plt, 'Benefit_function_figure_10',
                                r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

""" Start figure 1 """
"""
I want to recreate figure 1 here but I don't know how to do that.

1. To create a triangle I now use: px.line_ternary. But I don't know how to add the
    color differences of the fitness and the arrows of the direction. I also tried
    it in mathplotlib but that doesn't work very well either. So maybe you know a
    better way (possibly in mathplotlib)?
2. The line that is now being plotted does not correspond to what the figure in
    the article shows, so something is going wrong there as well. So maybe there
    is an error in the formulas that I can't find?
3. Furthermore, I don't know what to take as starting values for xOC, xOB and xMM
    and nOC, nOB and nMM because that is not stated anywhere?
4. I also don't know if I should update nOC, nOB and nMM in the loop? And if so does
    N stay te same number over different generations of does it become bigger.
5. And is fitness the average fitness or just one of the cell types?
"""

def dynamics_same_h_and_s(y, t, parameters):
    """Determines the frequenty dynamics in a population over time. The h value and s
    value are for all interactions the same.

    Parameters:
    -----------
    y : list
        Current state of the system, containing the frequencies and counts of each strategy.
        y = [xOC, xOB, xMM, nOC, nOB, nMM], where:
            xOC, xOB, xMM : float
                Frequencies of strategies OC, OB, and MM, respectively, ranging from 0 to 1.
            nOC, nOB, nMM : int
                Counts of individuals following strategies OC, OB, and MM, respectively.
    t : float
        Current time in the simulation.
    parameters : tuple
        Tuple containing parameters required for computation.
        parameters = (N, h, s, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value), where:
            N : int
                Total population size.
            h : float
                Inflection point value.
            s : float
                Steepness of the inflection points.
            BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM : float
                Maximal benefit values
    """
    xOC, xOB, xMM = y
    N, h, s, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value = parameters

    nOC = xOC * N
    nOB = xOB * N
    nMM = xMM * N

    # Calculate the benefit values
    bOC_OC = benefit_function(nOC, h, BOC_OC, s, N)
    bOB_OC = benefit_function(nOB, h, BOB_OC, s, N)
    bMM_OC = benefit_function(nMM, h, BMM_OC, s, N)

    bOC_OB = benefit_function(nOC, h, BOC_OB, s, N)
    bOB_OB = benefit_function(nOB, h, BOB_OB, s, N)
    bMM_OB = benefit_function(nMM, h, BMM_OB, s, N)

    bOC_MM = benefit_function(nOC, h, BOC_MM, s, N)
    bOB_MM = benefit_function(nOB, h, BOB_MM, s, N)
    bMM_MM = benefit_function(nMM, h, BMM_MM, s, N)

    # Determine the fitness values
    fitness_OC, fitness_OB, fitness_MM = calculate_fitness(N, xOC, xOB, xMM, bOC_OC, bOB_OC, bMM_OC, cOC_value, bOC_OB, bOB_OB, bMM_OB, cOB_value, bOC_MM, bOB_MM, bMM_MM, cMM_value)

    # Determine the change of the xOC, xOB, xMM values and W average value
    xOC_change, xOB_change, xMM_change, W_average = calculate_replicator_dynamics(
                                xOC, xOB, xMM, fitness_OC, fitness_OB, fitness_MM)

    return [xOC_change, xOB_change, xMM_change]

def dynamics_different_h_and_s(y, t, parameters):
    """
    Simulate the dynamics of a population with three strategies over time. The s and
    h value is deppendent on the interaction kind.

    Parameters:
    -----------
    y : list
        Current state of the system, containing the frequencies of each strategy.
        y = [xOC, xOB, xMM], where:
            xOC, xOB, xMM : float
                Frequencies of strategies OC, OB, and MM, respectively, ranging from 0 to 1.
    t : numpy.ndarray
        Array of time points at which the system is evaluated.
    parameters : tuple
        Tuple containing parameters required for computation.
        parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM,
                      sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM,
                      BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM,
                      cOC_value, cOB_value, cMM_value), where:
            N : int
                Total population size.
            hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM : float
                Values of h for each interaction between strategies.
            sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM : float
                Values of s for each interaction between strategies.
            BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM : float
                Benefit values for each interaction between strategies.
            cOC_value, cOB_value, cMM_value : float
                Cost values associated with each strategy.

    Returns:
    --------
    list
        List containing the changes in frequencies of each strategy.
        [xOC_change, xOB_change, xMM_change], where:
            xOC_change, xOB_change, xMM_change : float
                Changes in frequencies of strategies OC, OB, and MM, respectively.
    """
    # Unpack state variables and parameters
    xOC, xOB, xMM = y
    N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value = parameters

    # Calculate the number of individuals following each strategy
    nOC = xOC * N
    nOB = xOB * N
    nMM = xMM * N

    # Calculate benefit values for each interaction
    bOC_OC = benefit_function(nOC, hOC_OC, BOC_OC, sOC_OC, N)
    bOB_OC = benefit_function(nOB, hOB_OC, BOB_OC, sOB_OC, N)
    bMM_OC = benefit_function(nMM, hMM_OC, BMM_OC, sMM_OC, N)

    bOC_OB = benefit_function(nOC, hOC_OB, BOC_OB, sOC_OB, N)
    bOB_OB = benefit_function(nOB, hOB_OB, BOB_OB, sOB_OB, N)
    bMM_OB = benefit_function(nMM, hMM_OB, BMM_OB, sMM_OB, N)

    bOC_MM = benefit_function(nOC, hOC_MM, BOC_MM, sOC_MM, N)
    bOB_MM = benefit_function(nOB, hOB_MM, BOB_MM, sOB_MM, N)
    bMM_MM = benefit_function(nMM, hMM_MM, BMM_MM, sMM_MM, N)

    # Determine fitness values for each strategy
    fitness_OC, fitness_OB, fitness_MM = calculate_fitness(N, xOC, xOB, xMM,
                                bOC_OC, bOB_OC, bMM_OC, cOC_value, bOC_OB, bOB_OB,
                                 bMM_OB, cOB_value, bOC_MM, bOB_MM, bMM_MM, cMM_value)

    # Determine changes in strategy frequencies
    xOC_change, xOB_change, xMM_change, _ = calculate_replicator_dynamics(
                                xOC, xOB, xMM, fitness_OC, fitness_OB, fitness_MM)

    return [xOC_change, xOB_change, xMM_change]


def figure_1():
    """Function that recreates figure 1 in the paper of Sartakhti et al., 2018."""
    # Number of cells
    N = 10

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.2
    cMM_value = 0.3

    # Maximal benefit values
    BOC_OC = 0.0
    BOC_OB = 1.0
    BOC_MM = 1.1
    BOB_OC = 1.0
    BOB_OB = 0.0
    BOB_MM = 0.0
    BMM_OC = 1.1
    BMM_OB = -0.3
    BMM_MM = 0.0

    # Steepness and inflection point
    s = 1e-10
    h = 0.7

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.1
    xOB = 0.3
    xMM = 0.6

    nOC = 1
    nOB = 3
    nMM = 6

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, h, s, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 50, 50)

    # Solve ODE
    y = odeint(dynamics_same_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_1 = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_1, 'data_figure_1.csv', r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_1 = collect_data('data_figure_1.csv', r'..\data\reproduced_data_Sartakhti')

    # Make a plot
    data_figure_1.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('Fitness/ Frequency')
    plt.title('Bistability with linear benefits (figure 1)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_1', r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot
    """ So when i plot it in a ternary plot it does not go to the right point"""
    fig = px.line_ternary(data_figure_1, a='xOB', b='xMM', c='xOC')

    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text='Bistability with linear benefits (figure 1)')
    save_ternary(fig, 'Ternary_plot_figure_1',
                                r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

""" Sigmoid benefits figure 2"""
def figure_2():
    """Function that recreates the figures of figure 2 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 10

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.2
    cMM_value = 0.3

    # Maximal benefit values
    BOC_OC = 0
    BOC_OB = 1.0
    BOC_MM = 1.1
    BOB_OC = 1
    BOB_OB = 0
    BOB_MM = 0
    BMM_OC = 1.1
    BMM_OB = -0.3
    BMM_MM = 0

    # The inflection points
    h_values = [0.1, 0.3, 0.5, 0.7, 0.9]

    # Steepness of the function and a random maximal benefit for the demostration
    s_value = 20
    B_value = 1

    # Create a DataFrame to store the data
    df_sigmoides_figure_2 = pd.DataFrame(columns=['n_values', 'benefit_values', 'h_value'])

    # Loop over h values
    for h_value in h_values:
        n_values = np.linspace(0, N, 100)
        benefit_values = [benefit_function(n, h_value, B_value, s_value, N) for n in n_values]

        # Add the data to the dataframe
        df_sigmoides_figure_2 = pd.concat([df_sigmoides_figure_2, pd.DataFrame({
        'n_values': n_values, 'benefit_values': benefit_values, 'h_value': h_value})])

    # Save the data as csv file
    save_data(df_sigmoides_figure_2, 'data_sigmoides_figure_2.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_sigmoides_figure_2 = collect_data('data_sigmoides_figure_2.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a plot
    fig, axes = plt.subplots(1, len(h_values), figsize=(14, 5))
    for i, (h_value, group) in enumerate(data_sigmoides_figure_2.groupby('h_value')):
        axes[i].plot(group['n_values'], group['benefit_values'], label=f'h={h_value}')

        # Give titles
        axes[i].set_title(f'Sigmoide benefit h={h_value}')
        axes[i].set_xlabel('Number of producers')
        axes[i].set_ylabel('Benefit')
        axes[i].set_xticks([0, 10])
        axes[i].set_xticklabels(['0', 'N'], fontsize=11)
        axes[i].set_yticks([0, 1])
        axes[i].set_yticklabels(['0', r'$B_{ij}$'], fontsize=11)

    # Show the plot
    plt.tight_layout()
    save_figure(plt, 'Benefit_curves_figure_2',
                                r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    """Make the ternary plost of figure 2"""
    df_ternary_figure_2 = pd.DataFrame(columns=['Generation', 'xOC', 'xOB', 'xMM', 'h_value'])

    # Loop over the inflection point values
    for h_value in h_values:
        # Reset initial values for each h iteration
        xOC = 0.3
        xOB = 0.3
        xMM = 0.4
        N = 10
        nOC = 3
        nOB = 3
        nMM = 4

        # Cost of producing growth factors
        cOC_value = 0.1
        cOB_value = 0.2
        cMM_value = 0.3

        # Maximal benefit values
        BOC_OC = 0
        BOC_OB = 1.0
        BOC_MM = 1.1
        BOB_OC = 1
        BOB_OB = 0
        BOB_MM = 0
        BMM_OC = 1.1
        BMM_OB = -0.3
        BMM_MM = 0

        # Steepness of the function at the inflection point
        s_value = 20
        generations = 100

        # Set initial condition and parameters
        y0 = [xOC, xOB, xMM]
        parameters = (N, h_value, s_value, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value)
        t = np.linspace(0, 200)

        # Solve ODE
        y = odeint(dynamics_same_h_and_s, y0, t, args=(parameters,))

        # Extract the solution and create dataframe
        xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
        df = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})
        df['h_value'] = h_value
        df_ternary_figure_2 = pd.concat([df, df_ternary_figure_2], ignore_index=True)



        # # Loop for the number of generations
        # for generation in range(generations):
        #     # Calcuate the benefit values
        #     bOC_OC = benefit_function(nOC, h_value, BOC_OC, s_value, N)
        #     bOB_OC = benefit_function(nOB, h_value, BOB_OC, s_value, N)
        #     bMM_OC = benefit_function(nMM, h_value, BMM_OC, s_value, N)
        #
        #     bOC_OB = benefit_function(nOC, h_value, BOC_OB, s_value, N)
        #     bOB_OB = benefit_function(nOB, h_value, BOB_OB, s_value, N)
        #     bMM_OB = benefit_function(nMM, h_value, BMM_OB, s_value, N)
        #
        #     bOC_MM = benefit_function(nOC, h_value, BOC_MM, s_value, N)
        #     bOB_MM = benefit_function(nOB, h_value, BOB_MM, s_value, N)
        #     bMM_MM = benefit_function(nMM, h_value, BMM_MM, s_value, N)
        #
        #     # Determine the fitness values
        #     fitness_OC, fitness_OB, fitness_MM = calculate_fitness(N, xOC, xOB, xMM,
        #                         bOC_OC, bOB_OC, bMM_OC, cOC_value, bOC_OB, bOB_OB,
        #                         bMM_OB, cOB_value, bOC_MM, bOB_MM, bMM_MM, cMM_value)
        #
        #     # Determine the change of the xOC, xOB, xMM values and W average value
        #     xOC_change, xOB_change, xMM_change, W_average = calculate_replicator_dynamics(
        #                                 xOC, xOB, xMM, fitness_OC, fitness_OB, fitness_MM)
        #
        #     # Add row to DataFrame with 'h_value' column
        #     new_row = pd.DataFrame([{'Generation': generation, 'xOC': xOC, 'xOB': xOB,
        #                         'xMM': xMM, 'h_value': h_value}])
        #     df_ternary_figure_2 = pd.concat([df_ternary_figure_2 , new_row], ignore_index=True)
        #
        #
        #     # Update xOC, xOB, xMM values
        #     xOC = max(0, xOC + xOC_change)
        #     xOB = max(0, xOB + xOB_change)
        #     xMM = max(0, xMM + xMM_change)

    # Save the data as csv file
    save_data(df_ternary_figure_2, 'data_ternary_figure_2.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_teranary_figure_2 = collect_data('data_ternary_figure_2.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Loop over all the h values
    for h_value in h_values:
        # Create a subset DataFrame for the current h_value
        subset_df = data_teranary_figure_2[data_teranary_figure_2['h_value'] == h_value]
        fig = px.line_ternary(subset_df, a='xOB', b='xMM', c='xOC')
        fig.update_layout(
            ternary=dict(
                aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
                baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
                caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
        fig.update_layout(title_text=f"""Sigmoide benefits with an inflection point
        h at {h_value} (figure 2)""")
        name = f'subset_plot_h_{h_value}_figure_2'
        save_ternary(fig, name, r'..\visualisation\reproduced_results_Sartakhti')
        fig.show()


""" Start figure 3 line plot. But it is not correct"""
def figure_3():
    """Function that recreates the figures of figure 3 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 25

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.1
    cMM_value = 0.1

    # Maximal benefit values
    BOC_OC = 0.6
    BOB_OC = 1.0
    BMM_OC = 3.0
    BOC_OB = 1.1
    BOB_OB = 0.6
    BMM_OB = -0.5
    BOC_MM = 2.0
    BOB_MM = 0.0
    BMM_MM = 1.0

    # Positions of the inflection points
    hOC_OC = 0.0
    hOC_OB = 0.01
    hOC_MM = 0.2
    hOB_OC = 0.05
    hOB_OB = 0.05
    hOB_MM = 0.2
    hMM_OC = 0.5
    hMM_OB = 0.5
    hMM_MM = 0.5

    # Steepness of the function at the inflection points
    sOC_OC = 50
    sOC_OB = 30
    sOC_MM = 50
    sOB_OC = 30
    sOB_OB = 30
    sOB_MM = 30
    sMM_OC = 5
    sMM_OB = 20
    sMM_MM = 50

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.2
    xMM = 0.6
    nOC = 5
    nOB = 5
    nMM = 15

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_3_non_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.2
    xMM = 0.6
    nOC = 5
    nOB = 5
    nMM = 15


    s_linear = 1e-10

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_3_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_3_non_linear, 'data_figure_3_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    save_data(df_figure_3_linear, 'data_figure_3_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_3_non_linear = collect_data('data_figure_3_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    data_figure_3_linear = collect_data('data_figure_3_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a line plot of non-linear data
    data_figure_3_non_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Nonlinear benefits (figure 3)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_3_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of non-linear data
    fig = px.line_ternary(data_figure_3_non_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text=f'Nonliear benefits (figure 3)')
    save_ternary(fig, 'Ternary_plot_figure_3_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

    # Make a line plot of linear data
    data_figure_3_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Linear benfits (figure 3)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_3_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot  of linear data
    fig = px.line_ternary(data_figure_3_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Linear benefits (figure 3)')
    save_ternary(fig, 'Ternary_plot_figure_3_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

""" Start figure 4 line plot. But it is not correct"""
def figure_4():
    """Function that recreates the figures of figure 4 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 20

    # Cost of producing growth factors
    cOC_value = 1.5
    cOB_value = 0.5
    cMM_value = 2.0

    # Maximal benefit values
    BOC_OC = 0.6
    BOB_OC = 1.0
    BMM_OC = 3.0
    BOC_OB = 1.1
    BOB_OB = 0.5
    BMM_OB = -0.5
    BOC_MM = 2.3
    BOB_MM = 0.0
    BMM_MM = 1.5

    # Positions of the inflection points
    hOC_OC = 0.0
    hOC_OB = 0.0
    hOC_MM = 0.0
    hOB_OC = 0.0
    hOB_OB = 0.0
    hOB_MM = 0.0
    hMM_OC = 0.3
    hMM_OB = 0.5
    hMM_MM = 0.1

    # Steepness of the function at the inflection points
    sOC_OC = 10
    sOC_OB = 10
    sOC_MM = 100
    sOB_OC = 10
    sOB_OB = 10
    sOB_MM = 20
    sMM_OC = 10
    sMM_OB = 10
    sMM_MM = 100

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3
    nOC = 4
    nOB = 10
    nMM = 6
    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_4_non_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3
    nOC = 4
    nOB = 10
    nMM = 6

    s_linear = 10e-10
    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_4_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})


    # Save the data as csv file
    save_data(df_figure_4_non_linear, 'data_figure_4_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    save_data(df_figure_4_linear, 'data_figure_4_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_4_non_linear = collect_data('data_figure_4_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    data_figure_4_linear = collect_data('data_figure_4_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a line plot of non-linear data
    data_figure_4_non_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Non linear benefits (figure 4)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_4_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of non-linear data
    fig = px.line_ternary(data_figure_4_non_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Nonlinear benefits (figure 4)')
    save_ternary(fig, 'Ternary_plot_figure_4_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

    # Make a line plot of linear data
    data_figure_4_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Linear benefits (figure 4)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_4_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot  of linear data
    fig = px.line_ternary(data_figure_4_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Linear benefits (figure 4)')
    save_ternary(fig, 'Ternary_plot_figure_4_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

""" Start figure 5 line plot. But it is not correct"""
def figure_5():
    """Function that recreates the figures of figure 5 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 20

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.2
    cMM_value = 0.3

    # Maximal benefit values
    BOC_OC = 0.55
    BOB_OC = 1.0
    BMM_OC = 0.8
    BOC_OB = 1.1
    BOB_OB = 0.5
    BMM_OB = -0.5
    BOC_MM = 0.6
    BOB_MM = 0.0
    BMM_MM = 1.5

    # Positions of the inflection points
    hOC_OC = 0.0
    hOC_OB = 0.0
    hOC_MM = 0.0
    hOB_OC = 0.0
    hOB_OB = 0.0
    hOB_MM = 0.0
    hMM_OC = 0.3
    hMM_OB = 0.2
    hMM_MM = 0.1

    # Steepness of the function at the inflection points
    sOC_OC = 10
    sOC_OB = 10
    sOC_MM = 100
    sOB_OC = 10
    sOB_OB = 10
    sOB_MM = 20
    sMM_OC = 10
    sMM_OB = 10
    sMM_MM = 100

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3

    nOC = 4
    nOB = 10
    nMM = 6

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_5_non_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3

    nOC = 4
    nOB = 10
    nMM = 6

    s_linear = 10e-10
    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_5_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_5_non_linear, 'data_figure_5_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    save_data(df_figure_5_linear, 'data_figure_5_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_5_non_linear = collect_data('data_figure_5_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    data_figure_5_linear = collect_data('data_figure_5_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a line plot of non-linear data
    data_figure_5_non_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Nonlinear benefits (figure 5)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_5_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of non-linear data
    fig = px.line_ternary(data_figure_5_non_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Nonlinear benefits (figure 5)')
    save_ternary(fig, 'Ternary_plot_figure_5_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

    # Make a line plot of linear data
    data_figure_5_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.legend()
    plt.title('linear benefits (figure 5)')
    save_figure(plt, 'Line_plot_figure_5_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot  of linear data
    fig = px.line_ternary(data_figure_5_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Linear benefits (figure 5)')
    save_ternary(fig, 'Ternary_plot_figure_5_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

""" Start figure 6 line plot. But it is not correct"""
def figure_6():
    """Function that recreates the figures of figure 6 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 20

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.1
    cMM_value = 0.1

    # Maximal benefit values
    BOC_OC = 0.45
    BOB_OC = 0.9
    BMM_OC = 2.0
    BOC_OB = 0.9
    BOB_OB = 0.3
    BMM_OB = -0.3
    BOC_MM = 2.0
    BOB_MM = 0.0
    BMM_MM = 0.9

    # Positions of the inflection points
    hOC_OC = 0.05
    hOC_OB = 0.05
    hOC_MM = 0.5
    hOB_OC = 0.05
    hOB_OB = 0.05
    hOB_MM = 0.5
    hMM_OC = 0.5
    hMM_OB = 0.5
    hMM_MM = 0.5

    # Steepness of the function at the inflection points
    sOC_OC = 10
    sOC_OB = 10
    sOC_MM = 50
    sOB_OC = 10
    sOB_OB = 10
    sOB_MM = 10
    sMM_OC = 50
    sMM_OB = 50
    sMM_MM = 50

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3

    nOC = 4
    nOB = 10
    nMM = 6

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_6_non_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3

    nOC = 4
    nOB = 10
    nMM = 6

    s_linear = 10e-10
    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_6_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_6_non_linear, 'data_figure_6_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    save_data(df_figure_6_linear, 'data_figure_6_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_6_non_linear = collect_data('data_figure_6_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    data_figure_6_linear = collect_data('data_figure_6_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a line plot of non-linear data
    data_figure_6_non_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Nonlinear benefits (figure 6)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_6_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of non-linear data
    fig = px.line_ternary(data_figure_6_non_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Nonlinear benefits (figure 6)')
    save_ternary(fig, 'Ternary_plot_figure_6_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

    # Make a line plot of linear data
    data_figure_6_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Linear benefits (figure 6)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_6_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot  of linear data
    fig = px.line_ternary(data_figure_6_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Linear benefits (figure 6)')
    save_ternary(fig, 'Ternary_plot_figure_6_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

""" Start figure 7 line plot. But it is not correct"""
def figure_7():
    """Function that recreates the figures of figure 7 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 10

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.12
    cMM_value = 0.14

    # Maximal benefit values
    BOC_OC = 1.0
    BOB_OC = 0.7
    BMM_OC = 0.9
    BOC_OB = 1.0
    BOB_OB = 0.7
    BMM_OB = 0.9
    BOC_MM = 1.0
    BOB_MM = 0.7
    BMM_MM = 0.9

    # Positions of the inflection points
    hOC_OC = 0.4
    hOC_OB = 0.7
    hOC_MM = 0.1
    hOB_OC = 0.7
    hOB_OB = 0.4
    hOB_MM = 0.2
    hMM_OC = 0.4
    hMM_OB = 0.3
    hMM_MM = 0.7

    # Steepness of the function at the inflection points
    sOC_OC = 20
    sOC_OB = 20
    sOC_MM = 5
    sOB_OC = 10
    sOB_OB = 10
    sOB_MM = 50
    sMM_OC = 10
    sMM_OB = 5
    sMM_MM = 5

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3

    nOC = 2
    nOB = 5
    nMM = 3

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_7_non_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.2
    xOB = 0.5
    xMM = 0.3

    nOC = 2
    nOB = 5
    nMM = 3

    s_linear = 10e-10
    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_7_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_7_non_linear, 'data_figure_7_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    save_data(df_figure_7_linear, 'data_figure_7_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_7_non_linear = collect_data('data_figure_7_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    data_figure_7_linear = collect_data('data_figure_7_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a line plot of non-linear data
    data_figure_7_non_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Nonlinear benefits (figure 7)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_7_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of non-linear data
    fig = px.line_ternary(data_figure_7_non_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Nonlinear benefits (figure 7)')
    save_ternary(fig, 'Ternary_plot_figure_7_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

    # Make a line plot of linear data
    data_figure_7_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.legend('Linear benefits (figure 7)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_7_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot  of linear data
    fig = px.line_ternary(data_figure_7_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Linear benefits (figure 7)')
    save_ternary(fig, 'Ternary_plot_figure_7_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

""" Start figure 8 line plot. But it is not correct"""
def figure_8():
    """Function that recreates the figures of figure 8 in the paper of Sartakhti
    et al., 2018."""
    # Number of cells
    N = 20

    # Cost of producing growth factors
    cOC_value = 1.2
    cOB_value = 1.0
    cMM_value = 1.8

    # Maximal benefit values
    BOC_OC = 1.1
    BOB_OC = 0.95
    BMM_OC = 1.8
    BOC_OB = 1.1
    BOB_OB = 1.1
    BMM_OB = -0.35
    BOC_MM = 1.1
    BOB_MM = 1.5
    BMM_MM = 0.35

    # Positions of the inflection points
    hOC_OC = 0.0
    hOC_OB = 0.0
    hOC_MM = 0.0
    hOB_OC = 0.0
    hOB_OB = 0.0
    hOB_MM = 0.0
    hMM_OC = 0.2
    hMM_OB = 0.2
    hMM_MM = 0.2

    # Steepness of the function at the inflection points
    sOC_OC = 4
    sOC_OB = 4
    sOC_MM = 40
    sOB_OC = 4
    sOB_OB = 4
    sOB_MM = 4
    sMM_OC = 6
    sMM_OB = 6
    sMM_MM = 1000
    s_linear = 0.0001

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.1
    xOB = 0.2
    xMM = 0.7

    nOC = 2
    nOB = 4
    nMM = 16

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    sOC_OC, sOC_OB, sOC_MM, sOB_OC, sOB_OB, sOB_MM, sMM_OC, sMM_OB, sMM_MM, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_8_non_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Initial frequencies and values --> are needed to make a plot but are not mentioned
    xOC = 0.1
    xOB = 0.2
    xMM = 0.7

    nOC = 2
    nOB = 4
    nMM = 16

    s_linear = 10e-10
    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, hOC_OC, hOC_OB, hOC_MM, hOB_OC, hOB_OB, hOB_MM, hMM_OC, hMM_OB, hMM_MM, \
    s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, s_linear, \
    BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, \
    cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_different_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_8_linear = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_8_non_linear, 'data_figure_8_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    save_data(df_figure_8_linear, 'data_figure_8_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_8_non_linear = collect_data('data_figure_8_non_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')
    data_figure_8_linear = collect_data('data_figure_8_linear.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a line plot of non linear data
    data_figure_8_non_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Nonlinear benefits (figure 8)')
    plt.legend()

    save_figure(plt, 'Line_plot_figure_8_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of non linear data
    fig = px.line_ternary(data_figure_8_non_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Nonlinear benefits (figure 8)')
    save_ternary(fig, 'Ternary_plot_figure_8_non_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

    # Make a line plot of linear data
    data_figure_8_linear.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Linear benefits (figure 8)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_8_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot of linear data
    fig = px.line_ternary(data_figure_8_linear, a='xOB', b='xMM', c='xOC')
    fig.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))
    fig.update_layout(title_text= 'Linear benefits (figure 8)')
    save_ternary(fig, 'Ternary_plot_figure_8_linear',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    fig.show()

def figure_9():
    """Function that recreates the figures of figure 9 in the paper of Sartakhti
    et al., 2018."""

    # Make the needed dataframes
    column_names = ['Generation', 'xOC', 'xOB', 'xMM', 'W_average']
    df_figure_9_no_treatment = pd.DataFrame(columns=column_names)
    df_figure_9_reducing_MM = pd.DataFrame(columns=column_names)
    df_figure_9_increasing_h = pd.DataFrame(columns=column_names)

    # Reset initial values for each h iteration
    xOC = 0.5
    xOB = 0.4
    xMM = 0.1
    N = 10
    nOC = 5
    nOB = 4
    nMM = 1

    # Cost of producing growth factors
    cOC_value = 0.1
    cOB_value = 0.2
    cMM_value = 0.3

    # Maximal benefit values
    BOC_OC = 0
    BOC_OB = 1.0
    BOC_MM = 1.1
    BOB_OC = 1
    BOB_OB = 0
    BOB_MM = 0
    BMM_OC = 1.1
    BMM_OB = -0.3
    BMM_MM = 0

    # Steepness of the function and a random maximal benefit for the demostration
    s_value = 20
    h_value = 0.3

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, h_value, s_value, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_same_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_9_no_treatment = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_9_no_treatment, 'data_figure_9_no_treatment.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_9_no_treatment = collect_data('data_figure_9_no_treatment.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Reset initial values for each h iteration
    xOC = 0.8
    xOB = 0.1
    xMM = 0.1
    N = 10
    nOC = 8
    nOB = 1
    nMM = 1

    # Steepness of the function and a random maximal benefit for the demostration
    s_value = 20
    h_value = 0.3

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, h_value, s_value, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_same_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_9_reducing_MM = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_9_reducing_MM, 'data_figure_9_reducing_MM.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_9_reducing_MM = collect_data('data_figure_9_reducing_MM.csv',
                                                r'..\data\reproduced_data_Sartakhti')


    # Reset initial values for each h iteration
    xOC = 0.6
    xOB = 0.01
    xMM = 0.39
    N = 10
    nOC = 6
    nOB = 0.1
    nMM = 3.9

    # Steepness of the function and a random maximal benefit for the demostration
    s_value = 20
    h_value = 0.7

    # Set initial condition and parameters
    y0 = [xOC, xOB, xMM]
    parameters = (N, h_value, s_value, BOC_OC, BOB_OC, BMM_OC, BOC_OB, BOB_OB, BMM_OB, BOC_MM, BOB_MM, BMM_MM, cOC_value, cOB_value, cMM_value)
    t = np.linspace(0, 100)

    # Solve ODE
    y = odeint(dynamics_same_h_and_s, y0, t, args=(parameters,))

    # Extract the solution and create dataframe
    xOC_values, xOB_values, xMM_values = y[:, 0], y[:, 1], y[:, 2]
    df_figure_9_increasing_h = pd.DataFrame({'Generation': t, 'xOC': xOC_values, 'xOB': xOB_values, 'xMM': xMM_values})

    # Save the data as csv file
    save_data(df_figure_9_increasing_h, 'data_figure_9_increasing_h.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Collect the dataframe from the csv file
    data_figure_9_increasing_h = collect_data('data_figure_9_increasing_h.csv',
                                                r'..\data\reproduced_data_Sartakhti')

    # Make a ternary plot to show the effect of a decrease in MM cells
    fig1 = px.line_ternary(data_figure_9_reducing_MM, a='xOB', b='xMM', c='xOC')
    fig2 = px.line_ternary(data_figure_9_no_treatment, a='xOB', b='xMM', c='xOC')
    fig1.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))


    # Add both lines to one ternary plot
    for trace in fig2.data:
        fig1.add_trace(trace)
    fig1.data[0].update(line=dict(color='red'))
    fig1.data[1].update(line=dict(color='blue'))
    fig1.update_layout(title_text= 'Reducing MM cells (figure 9)')
    save_ternary(fig1, 'Ternary_plot_figure_9_reducing_MM',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    # fig1.show()

    # Make a line plot of the effect of a decrease in MM cells
    data_figure_9_reducing_MM.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Reducing MM cells (figure 9)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_9_reducing_MM',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

    # Make a ternary plot to show the effect of an increase in h
    fig3 = px.line_ternary(data_figure_9_increasing_h, a='xOB', b='xMM', c='xOC')
    fig3.update_layout(
        ternary=dict(
            aaxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            baxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),
            caxis=dict(ticks='outside', tickvals=[0, 0.25, 0.5, 0.75, 1]),))


    # Add both lines to one ternary plot
    for trace in fig2.data:
        fig3.add_trace(trace)
    fig3.data[0].update(line=dict(color='red'))
    fig3.data[1].update(line=dict(color='blue'))
    fig3.update_layout(title_text= 'Increasing h (figure 9)')
    save_ternary(fig3, 'Ternary_plot_figure_9_increasing_h',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    # fig3.show()

    # Make a line plot of the effect of a increase in the h value
    data_figure_9_increasing_h.plot(x= 'Generation', y= ['xOC', 'xOB', 'xMM'])
    plt.legend(['Frequency OC', 'Frequency OB', 'Frequency MM', 'Average fitness'])
    plt.xlabel('Generations')
    plt.ylabel('fitness/ frequency')
    plt.title('Increase of the inflection point h (figure 9)')
    plt.legend()
    save_figure(plt, 'Line_plot_figure_9_increasing_h',
                                    r'..\visualisation\reproduced_results_Sartakhti')
    plt.show()

if __name__ == "__main__":
    main()
